<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Metal RPS Arena</title>
    <style>
        :root {
            --metal-dark-gray: #2c3e50;
            --metal-mid-gray: #596a7b;
            --metal-light-gray: #bdc3c7;
            --metal-silver: #e0e0e0;
            --glow-blue: #3498db;
            --glow-red: #e74c3c;
            --glow-green: #2ecc71;
            --glow-yellow: #f39c12;
            --screen-bg: #0a0f14;
            --font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
        }

        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: var(--font-family);
            background-color: var(--metal-dark-gray);
            color: var(--metal-silver);
            touch-action: manipulation;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
        }

        .hidden {
            display: none !important;
        }

        #app-container {
            width: 100%;
            max-width: 500px;
            height: 100%;
            max-height: 900px;
            background: linear-gradient(145deg, #4d5c6b, #2f3a46);
            border-radius: 20px;
            box-shadow: 
                inset 0 0 15px rgba(0,0,0,0.6),
                0 10px 30px rgba(0,0,0,0.5);
            border: 3px solid #1a222a;
            display: flex;
            flex-direction: column;
            padding: 20px;
            transform: rotateX(5deg);
            transition: transform 0.5s;
        }
        
        @media (max-width: 600px) {
            #app-container {
                max-width: 100%;
                max-height: 100%;
                height: 100dvh;
                border-radius: 0;
                padding: 10px;
                transform: none;
            }
        }

        #game-machine {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-screen {
            flex-grow: 1;
            background-color: var(--screen-bg);
            border: 5px solid var(--metal-dark-gray);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.8);
            clip-path: polygon(5% 0, 95% 0, 100% 10%, 100% 90%, 95% 100%, 5% 100%, 0 90%, 0 10%);
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        #top-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.05) 1px, transparent 1px);
            background-size: 30px 30px;
            pointer-events: none;
            z-index: 1;
        }
        
        #top-screen::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0) 60%);
            animation: screen-flicker 15s infinite linear;
        }

        @keyframes screen-flicker {
            0% { transform: translate(0, 0); }
            25% { transform: translate(5px, 5px); }
            50% { transform: translate(-5px, 0); }
            75% { transform: translate(0, -5px); }
            100% { transform: translate(0, 0); }
        }

        #control-panel {
            padding-top: 20px;
        }

        #button-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
        }

        .control-button {
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            border: 3px solid var(--metal-dark-gray);
            background: linear-gradient(145deg, var(--metal-mid-gray), var(--metal-dark-gray));
            box-shadow: 
                -5px -5px 10px rgba(255,255,255,0.1), 
                5px 5px 10px rgba(0,0,0,0.5),
                inset 0 0 5px rgba(0,0,0,0.5);
            font-size: 3rem;
            cursor: pointer;
            transition: all 0.2s ease-out;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
        }
        
        .control-button:hover:not(:disabled) {
            transform: translateY(-5px);
            box-shadow: 
                -5px -5px 15px rgba(52, 152, 219, 0.5), 
                5px 5px 15px rgba(0,0,0,0.7),
                inset 0 0 10px rgba(52, 152, 219, 0.3);
            filter: brightness(1.2);
        }

        .control-button.selected {
            transform: translateY(2px);
            background: var(--glow-blue);
            box-shadow: 0 0 20px var(--glow-blue), inset 0 0 10px rgba(255,255,255,0.5);
            color: white;
        }
        
        .control-button:active:not(:disabled) {
            transform: translateY(2px);
            filter: brightness(0.9);
        }

        .control-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            filter: grayscale(80%);
        }
        
        .screen-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2;
            position: relative;
        }

        #login-screen button, #lobby-screen button, .modal button {
            background: var(--metal-mid-gray);
            border: 2px solid var(--metal-light-gray);
            color: var(--metal-silver);
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 5px;
            font-size: 1rem;
        }
        #login-screen button:hover, #lobby-screen button:hover, .modal button:hover {
            background: var(--glow-blue);
            border-color: var(--metal-silver);
        }

        #login-screen input {
            background: var(--metal-dark-gray);
            border: 1px solid var(--metal-mid-gray);
            color: var(--metal-silver);
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
            width: 80%;
            max-width: 300px;
        }

        #lobby-screen ul {
            list-style: none;
            width: 90%;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border: 1px solid var(--metal-mid-gray);
            padding: 10px;
            border-radius: 5px;
        }
        #lobby-screen li {
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid var(--metal-mid-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #lobby-screen li:hover {
            background-color: var(--glow-blue);
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
        }
        .status-online { background-color: var(--glow-green); }
        .status-ingame { background-color: var(--glow-red); }

        #game-screen-content {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }
        
        #game-info {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 5px 0;
            background: rgba(0,0,0,0.5);
            border-radius: 5px;
            font-size: 0.8rem;
        }
        .player-info { text-align: center; }

        #video-streams {
            flex-grow: 1;
            display: flex;
            gap: 10px;
            width: 100%;
            padding: 10px 0;
            min-height: 0;
        }

        .video-container {
            flex: 1;
            position: relative;
            background: #000;
            border: 2px solid var(--metal-mid-gray);
            border-radius: 10px;
            overflow: hidden;
            box-shadow: inset 0 0 10px #000;
        }
        
        .video-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #local-video {
            transform: scaleX(-1);
        }

        .video-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 0.7rem;
            z-index: 5;
        }

        #game-status-display {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.85);
            z-index: 10;
            padding: 20px;
        }
        
        #game-status-text {
            font-size: 3rem;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 20px var(--glow-blue);
            animation: pulse 1.5s infinite;
            margin-bottom: 20px;
        }

        #game-choices-display {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            margin: 20px 0;
        }

        .choice-item {
            text-align: center;
        }

        .choice-emoji {
            font-size: 4rem;
            margin-bottom: 10px;
        }

        .choice-label {
            font-size: 1rem;
            color: var(--metal-light-gray);
        }

        .vs-text {
            font-size: 2rem;
            font-weight: bold;
            color: var(--glow-yellow);
        }

        #winner-display {
            font-size: 1.5rem;
            margin-top: 20px;
            padding: 10px 20px;
            border-radius: 10px;
            background: rgba(0,0,0,0.5);
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .result-win { text-shadow: 0 0 20px var(--glow-green) !important; color: var(--glow-green) !important; }
        .result-lose { text-shadow: 0 0 20px var(--glow-red) !important; color: var(--glow-red) !important; }
        .result-draw { text-shadow: 0 0 20px var(--metal-silver) !important; color: var(--metal-silver) !important; }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #4d5c6b, #2f3a46);
            border: 2px solid var(--metal-silver);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            z-index: 100;
            width: 90%;
            max-width: 400px;
        }

        .modal-content {
            text-align: center;
        }
        
        .modal input {
            width: 100px;
            text-align: center;
            font-size: 1.2rem;
            margin: 10px auto;
            display: block;
            background: var(--metal-dark-gray);
            border: 1px solid var(--metal-mid-gray);
            color: var(--metal-silver);
            padding: 10px;
            border-radius: 5px;
        }

        .lobby-buttons button {
            margin: 0 5px;
        }

        @media (max-width: 600px) {
            #game-status-text {
                font-size: 2rem;
            }
            .choice-emoji {
                font-size: 3rem;
            }
            .vs-text {
                font-size: 1.5rem;
            }
            #winner-display {
                font-size: 1.2rem;
            }
        }

    </style>
</head>
<body>
    <div id="app-container">
        <div id="game-machine">
            <div id="top-screen">
                <div id="login-screen" class="screen-content">
                    <h2>Metal RPS Arena</h2>
                    <input type="email" id="email" placeholder="Email" autocomplete="email">
                    <input type="password" id="password" placeholder="Password" autocomplete="current-password">
                    <button id="login-btn">Login</button>
                    <button id="signup-btn">Sign Up</button>
                    <p>or</p>
                    <button id="google-login-btn">Sign In with Google</button>
                    <p id="auth-error" class="hidden" style="color: var(--glow-red);"></p>
                </div>

                <div id="lobby-screen" class="screen-content hidden">
                    <h3>Lobby</h3>
                    <div id="user-info" style="margin-bottom: 10px;">
                        <span id="user-display-name"></span> - üí∞<span id="user-wallet"></span> coins
                    </div>
                    <h4>Online Players:</h4>
                    <ul id="players-list"></ul>
                    <div class="lobby-buttons">
                        <button id="wallet-btn">Wallet</button>
                        <button id="logout-btn">Logout</button>
                    </div>
                </div>

                <div id="game-screen" class="screen-content hidden">
                    <div id="game-screen-content">
                        <div id="game-info">
                            <div class="player-info">
                                <span id="local-player-name">You</span><br>
                                üí∞<span id="local-player-wallet">0</span>
                            </div>
                            <div class="player-info">
                                Pot: üí∞<span id="game-bet-amount">0</span>
                            </div>
                            <div class="player-info">
                                <span id="remote-player-name">Opponent</span><br>
                                üí∞<span id="remote-player-wallet">0</span>
                            </div>
                        </div>
                        <div id="video-streams">
                            <div class="video-container">
                                <div class="video-label">You</div>
                                <video id="local-video" autoplay muted playsinline></video>
                            </div>
                            <div class="video-container">
                                <div class="video-label">Opponent</div>
                                <video id="remote-video" autoplay playsinline></video>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="game-status-display" class="hidden">
                    <h1 id="game-status-text"></h1>
                    <div id="game-choices-display" class="hidden">
                        <div class="choice-item">
                            <div class="choice-emoji" id="player1-choice-emoji"></div>
                            <div class="choice-label" id="player1-choice-label"></div>
                        </div>
                        <div class="vs-text">VS</div>
                        <div class="choice-item">
                            <div class="choice-emoji" id="player2-choice-emoji"></div>
                            <div class="choice-label" id="player2-choice-label"></div>
                        </div>
                    </div>
                    <div id="winner-display" class="hidden"></div>
                </div>

                <div id="modal-container"></div>
            </div>
            <div id="control-panel">
                <div id="button-grid">
                    <button class="control-button" id="rock-btn" data-choice="rock">ü™®</button>
                    <button class="control-button" id="paper-btn" data-choice="paper">üìÑ</button>
                    <button class="control-button" id="scissors-btn" data-choice="scissors">‚úÇÔ∏è</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>

    <script type="module">
        const firebaseConfig = {
            apiKey: "AIzaSyCjdjNpyDG1wXGyxG65Pa0jlehVGW52u_Y",
            authDomain: "piedra-papel-o-tijeras-5ae53.firebaseapp.com",
            databaseURL: "https://piedra-papel-o-tijeras-5ae53-default-rtdb.firebaseio.com",
            projectId: "piedra-papel-o-tijeras-5ae53",
            storageBucket: "piedra-papel-o-tijeras-5ae53.appspot.com",
            messagingSenderId: "394850327081",
            appId: "1:394850327081:web:96d0e21ce3bf4e67da1a38",
            measurementId: "G-C3VE5H0Y3S"
        };
        
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();
        const googleProvider = new firebase.auth.GoogleAuthProvider();

        let appState = {
            currentUser: null,
            currentUserProfile: null,
            currentGameId: null,
            localStream: null,
            peer: null,
            isGameCreator: false,
            playerChoice: null,
            activeGameListener: null,
            pendingInvitation: null, 
            activeInvitationListener: null,
        };

        const dom = {
            loginScreen: document.getElementById('login-screen'),
            lobbyScreen: document.getElementById('lobby-screen'),
            gameScreen: document.getElementById('game-screen'),
            authError: document.getElementById('auth-error'),
            playersList: document.getElementById('players-list'),
            userDisplayName: document.getElementById('user-display-name'),
            userWallet: document.getElementById('user-wallet'),
            modalContainer: document.getElementById('modal-container'),
            controlButtons: document.querySelectorAll('.control-button'),
            gameStatusDisplay: document.getElementById('game-status-display'),
            gameStatusText: document.getElementById('game-status-text'),
            gameChoicesDisplay: document.getElementById('game-choices-display'),
            player1ChoiceEmoji: document.getElementById('player1-choice-emoji'),
            player1ChoiceLabel: document.getElementById('player1-choice-label'),
            player2ChoiceEmoji: document.getElementById('player2-choice-emoji'),
            player2ChoiceLabel: document.getElementById('player2-choice-label'),
            winnerDisplay: document.getElementById('winner-display'),
            localVideo: document.getElementById('local-video'),
            remoteVideo: document.getElementById('remote-video'),
            localPlayerName: document.getElementById('local-player-name'),
            remotePlayerName: document.getElementById('remote-player-name'),
            localPlayerWallet: document.getElementById('local-player-wallet'),
            remotePlayerWallet: document.getElementById('remote-player-wallet'),
            gameBetAmount: document.getElementById('game-bet-amount'),
        };

        const choiceEmojis = {
            rock: 'ü™®',
            paper: 'üìÑ',
            scissors: '‚úÇÔ∏è'
        };

        const sounds = {
            click: new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAA//8/"),
            countdown: new Audio("data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAIARKwAABCxAgAEABAAZGF0YUgAAACEgD8/Pz9ISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhI////"),
            alarm: new Audio("data:audio/wav;base64,UklGRlIAAABXQVZFZm10IBAAAAABAAIARKwAABCxAgAEABAAZGF0YUgAAACIh0BAPz9AQEBAPz8/QEBAPz9AQEBAPz9AQEBAPz9AQEBAPz9AQEBAPz9AQEBAPz9AQEBAPz9AQEBAPz9AQEBAPz8/Pz8/Pz8="),
            win: new Audio("data:audio/wav;base64,UklGRjQAAABXQVZFZm10IBAAAAABAAIARKwAABCxAgAEABAAZGF0YRAAAAAA/gD+AP4A/gD+APgA+QD5APkA/AD4APkA+AD8APwA/gD+AP4AAAAA"),
            lose: new Audio("data:audio/wav;base64,UklGRjQAAABXQVZFZm10IBAAAAABAAIARKwAABCxAgAEABAAZGF0YRAAAAAA/gD+AP4A/AD4APkA+AD8APkA+QD4APwA/gD+AP4A/gAAAAA="),
            draw: new Audio("data:audio/wav;base64,UklGRjAAAABXQVZFZm10IBAAAAABAAIARKwAABCxAgAEABAAZGF0YQ4AAAAA/gD+AP4A/AD4APgA/AD+AP4AAAAA"),
            play: (sound) => {
                try {
                    sounds[sound].currentTime = 0;
                    sounds[sound].play().catch(e => {});
                } catch (e) {}
            }
        };

        const ui = {
            showScreen: (screen) => {
                [dom.loginScreen, dom.lobbyScreen, dom.gameScreen].forEach(s => s.classList.add('hidden'));
                if(screen) screen.classList.remove('hidden');
            },
            showAuthError: (message) => {
                dom.authError.textContent = message;
                dom.authError.classList.remove('hidden');
            },
            hideAuthError: () => dom.authError.classList.add('hidden'),
            renderPlayers: (players) => {
                dom.playersList.innerHTML = '';
                Object.keys(players).forEach(uid => {
                    if (uid === appState.currentUser.uid) return;
                    const player = players[uid];
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span><span class="status-dot ${player.status === 'online' ? 'status-online' : 'status-ingame'}"></span>${player.displayName}</span>
                        <span>üí∞${player.wallet}</span>`;
                    if (player.status === 'online') {
                        li.onclick = () => ui.showChallengeModal(uid, player.displayName);
                    } else {
                        li.style.cursor = 'not-allowed';
                        li.style.opacity = '0.5';
                    }
                    dom.playersList.appendChild(li);
                });
            },
            updateLobbyHeader: () => {
                if(appState.currentUserProfile) {
                    dom.userDisplayName.textContent = appState.currentUserProfile.displayName;
                    dom.userWallet.textContent = appState.currentUserProfile.wallet;
                }
            },
            showChallengeModal: (opponentId, opponentName) => {
                const modalHTML = `
                    <div class="modal" id="challenge-modal">
                        <div class="modal-content">
                            <h3>Challenge ${opponentName}</h3>
                            <p>Enter bet amount (min 5):</p>
                            <input type="number" id="bet-amount-input" value="5" min="5">
                            <button id="send-challenge-btn">Send Challenge</button>
                            <button id="cancel-challenge-btn">Cancel</button>
                        </div>
                    </div>
                `;
                dom.modalContainer.innerHTML = modalHTML;
                document.getElementById('send-challenge-btn').onclick = () => {
                    const betAmount = parseInt(document.getElementById('bet-amount-input').value);
                    if (betAmount >= 5 && betAmount <= appState.currentUserProfile.wallet) {
                        game.sendInvitation(opponentId, opponentName, betAmount);
                        ui.hideModal();
                    } else {
                        alert("Invalid bet amount. Check your wallet balance or the minimum bet.");
                    }
                };
                document.getElementById('cancel-challenge-btn').onclick = ui.hideModal;
            },
            showInvitationModal: (invitationSnap) => {
                if (document.getElementById('invitation-modal')) return;
                const invitation = invitationSnap.val();
                if (!invitation) return; 
                const invitationRef = invitationSnap.ref;

                const modalHTML = `
                    <div class="modal" id="invitation-modal">
                        <div class="modal-content">
                            <h3>Incoming Challenge!</h3>
                            <p>${invitation.fromName} challenges you to a game for üí∞${invitation.bet} coins!</p>
                            <button id="accept-challenge-btn">Accept</button>
                            <button id="decline-challenge-btn">Decline</button>
                        </div>
                    </div>
                `;
                dom.modalContainer.innerHTML = modalHTML;
                
                document.getElementById('accept-challenge-btn').onclick = () => {
                    game.acceptInvitation(invitation.gameId, invitationRef);
                    ui.hideModal(); 
                };

                document.getElementById('decline-challenge-btn').onclick = () => {
                    game.declineInvitation(invitation.gameId, invitationRef);
                    ui.hideModal();
                };
            },
            showWaitingModal: (opponentName) => {
                const modalHTML = `
                    <div class="modal" id="waiting-modal">
                        <div class="modal-content">
                            <h3>Invitation Sent</h3>
                            <p>Waiting for ${opponentName} to respond...</p>
                            <button id="cancel-invitation-btn">Cancel Invitation</button>
                        </div>
                    </div>
                `;
                dom.modalContainer.innerHTML = modalHTML;
                document.getElementById('cancel-invitation-btn').onclick = game.cancelInvitation;
            },
            showWalletModal: () => {
                const modalHTML = `
                    <div class="modal" id="wallet-modal">
                        <div class="modal-content">
                            <h3>Wallet</h3>
                            <p>Current Balance: üí∞${appState.currentUserProfile.wallet}</p>
                            <button id="deposit-btn">Deposit</button>
                            <button id="withdraw-btn">Withdraw</button>
                            <button id="close-wallet-btn">Close</button>
                        </div>
                    </div>
                `;
                dom.modalContainer.innerHTML = modalHTML;
                document.getElementById('deposit-btn').onclick = () => alert('Deposit feature coming soon!');
                document.getElementById('withdraw-btn').onclick = () => alert('Withdrawal feature coming soon!');
                document.getElementById('close-wallet-btn').onclick = ui.hideModal;
            },
            hideModal: () => {
                dom.modalContainer.innerHTML = '';
            },
            showGameStatus: (text, type = '', duration = 0) => {
                dom.gameStatusText.textContent = text;
                dom.gameStatusText.className = type ? `result-${type}` : '';
                dom.gameStatusDisplay.classList.remove('hidden');
                dom.gameChoicesDisplay.classList.add('hidden');
                dom.winnerDisplay.classList.add('hidden');
                if(duration > 0) {
                    setTimeout(() => dom.gameStatusDisplay.classList.add('hidden'), duration);
                }
            },
            hideGameStatus: () => {
                dom.gameStatusDisplay.classList.add('hidden');
                dom.gameChoicesDisplay.classList.add('hidden');
                dom.winnerDisplay.classList.add('hidden');
            },
            showGameResult: (gameData) => {
                const { p1, p2 } = gameData.players;
                const myUid = appState.currentUser.uid;
                const amP1 = p1.uid === myUid;
                
                const myChoice = amP1 ? p1.choice : p2.choice;
                const opponentChoice = amP1 ? p2.choice : p1.choice;

                const myName = amP1 ? p1.displayName : p2.displayName;
                const opponentName = amP1 ? p2.displayName : p1.displayName;
                
                dom.player1ChoiceEmoji.textContent = choiceEmojis[myChoice];
                dom.player1ChoiceLabel.textContent = `${myName}: ${myChoice.toUpperCase()}`;
                
                dom.player2ChoiceEmoji.textContent = choiceEmojis[opponentChoice];
                dom.player2ChoiceLabel.textContent = `${opponentName}: ${opponentChoice.toUpperCase()}`;
                
                dom.gameChoicesDisplay.classList.remove('hidden');
                
                let resultText, resultClass, winnerName;
                const winnerChoice = game.getWinner(p1.choice, p2.choice);

                if (winnerChoice === null) {
                    resultText = "IT'S A DRAW!";
                    resultClass = "draw";
                    winnerName = "Nobody wins";
                } else if (myChoice === winnerChoice) {
                    resultText = "YOU WIN!";
                    resultClass = "win";
                    winnerName = `Winner: ${myName}`;
                } else {
                    resultText = "YOU LOSE!";
                    resultClass = "lose";
                    winnerName = `Winner: ${opponentName}`;
                }
                
                dom.gameStatusText.textContent = resultText;
                dom.gameStatusText.className = `result-${resultClass}`;
                
                dom.winnerDisplay.textContent = winnerName;
                dom.winnerDisplay.classList.remove('hidden');
                
                dom.gameStatusDisplay.classList.remove('hidden');
            },
            resetControlButtons: (disabled = false) => {
                dom.controlButtons.forEach(btn => {
                    btn.classList.remove('selected');
                    btn.disabled = disabled;
                });
            },
            updateGameInfo: (gameData) => {
                if (!gameData || !gameData.players) return;
                const myUid = appState.currentUser.uid;
                const p1Data = gameData.players.p1;
                const p2Data = gameData.players.p2;

                if (!p1Data || !p2Data) return;

                const amP1 = p1Data.uid === myUid;
                const localPlayer = amP1 ? p1Data : p2Data;
                const remotePlayer = amP1 ? p2Data : p1Data;
                
                dom.localPlayerName.textContent = localPlayer.displayName;
                dom.localPlayerWallet.textContent = localPlayer.wallet;
                dom.remotePlayerName.textContent = remotePlayer.displayName;
                dom.remotePlayerWallet.textContent = remotePlayer.wallet;
                dom.gameBetAmount.textContent = gameData.bet * 2;
            }
        };

        const authManager = {
            init: () => {
                document.getElementById('login-btn').addEventListener('click', authManager.login);
                document.getElementById('signup-btn').addEventListener('click', authManager.signup);
                document.getElementById('google-login-btn').addEventListener('click', authManager.googleLogin);
                document.getElementById('logout-btn').addEventListener('click', authManager.logout);
                document.getElementById('wallet-btn').addEventListener('click', ui.showWalletModal);
                
                auth.onAuthStateChanged(user => {
                    if (user) {
                        appState.currentUser = user;
                        dbManager.onUserConnect();
                        dbManager.listenToProfile(user.uid);
                        dbManager.listenToPlayers();
                        dbManager.listenForInvitations(user.uid);
                        ui.showScreen(dom.lobbyScreen);
                    } else {
                        appState.currentUser = null;
                        appState.currentUserProfile = null;
                        ui.showScreen(dom.loginScreen);
                    }
                });
            },
            login: () => auth.signInWithEmailAndPassword(document.getElementById('email').value, document.getElementById('password').value).catch(e => ui.showAuthError(e.message)),
            signup: () => auth.createUserWithEmailAndPassword(document.getElementById('email').value, document.getElementById('password').value).then(cred => dbManager.createUserProfile(cred.user)).catch(e => ui.showAuthError(e.message)),
            googleLogin: () => auth.signInWithPopup(googleProvider).then(result => { if (result.additionalUserInfo.isNewUser) { dbManager.createUserProfile(result.user); }}).catch(e => ui.showAuthError(e.message)),
            logout: () => auth.signOut(),
        };

        const dbManager = {
            createUserProfile: (user) => db.ref(`users/${user.uid}`).set({ uid: user.uid, displayName: user.displayName || user.email.split('@')[0], email: user.email, wallet: 100, status: 'online'}),
            onUserConnect: () => {
                const userStatusRef = db.ref(`/users/${appState.currentUser.uid}`);
                db.ref('.info/connected').on('value', snap => {
                    if (snap.val() === false) return;
                    userStatusRef.onDisconnect().update({ status: 'offline' }).then(() => {
                        userStatusRef.update({ status: 'online' });
                    });
                });
            },
            updateUserStatus: (status) => { if(appState.currentUser) db.ref(`/users/${appState.currentUser.uid}/status`).set(status); },
            listenToProfile: (uid) => db.ref(`users/${uid}`).on('value', snap => { appState.currentUserProfile = snap.val(); ui.updateLobbyHeader(); }),
            listenToPlayers: () => db.ref('users').on('value', snap => ui.renderPlayers(snap.val() || {})),
            listenForInvitations: (uid) => {
                const invitationsRef = db.ref(`invitations/${uid}`);
                invitationsRef.on('child_added', (snap) => {
                    const invitation = snap.val();
                    if (!invitation || !invitation.gameId) return;
                    
                    db.ref(`games/${invitation.gameId}`).once('value', (gameSnap) => {
                        if (gameSnap.exists() && gameSnap.val().status === 'pending') {
                            ui.showInvitationModal(snap);
                        } else {
                            snap.ref.remove();
                        }
                    });
                });
                
                invitationsRef.on('child_removed', () => {
                    if (document.getElementById('invitation-modal')) {
                        ui.hideModal();
                    }
                });
            }
        };
        
        const webrtc = {
            start: async () => {
                try {
                    const constraints = {
                        video: {
                            facingMode: 'user',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        },
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    };
                    
                    appState.localStream = await navigator.mediaDevices.getUserMedia(constraints);
                    dom.localVideo.srcObject = appState.localStream;
                    
                    await dom.localVideo.play();
                    
                } catch (e) {
                    console.error("WebRTC start failed:", e);
                    alert("Could not access camera/microphone. Please check permissions and refresh.");
                    game.leave();
                    return;
                }

                // **IMPROVED WebRTC configuration with TURN servers**
                const iceServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    // Adding public TURN servers for better connectivity
                    { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
                    { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
                ];

                appState.peer = new SimplePeer({
                    initiator: appState.isGameCreator,
                    stream: appState.localStream,
                    trickle: false,
                    config: { iceServers }
                });

                const signalRef = db.ref(`games/${appState.currentGameId}/signals`);
                const mySignalKey = appState.isGameCreator ? 'p1Signal' : 'p2Signal';
                const opponentSignalKey = appState.isGameCreator ? 'p2Signal' : 'p1Signal';

                appState.peer.on('signal', data => {
                    signalRef.child(mySignalKey).set(JSON.stringify(data));
                });
                
                appState.peer.on('stream', stream => {
                    dom.remoteVideo.srcObject = stream;
                    dom.remoteVideo.play().catch(e => {
                        console.log("Autoplay prevented, trying with user interaction");
                    });
                });

                appState.peer.on('connect', () => {
                    console.log('Peer connection established');
                     // Only the creator starts the countdown once connection is established
                    if (appState.isGameCreator) {
                        setTimeout(() => game.startCountdown(), 1000);
                    }
                });

                appState.peer.on('close', () => {
                    console.log('Peer connection closed');
                    game.leave();
                });
                
                appState.peer.on('error', (err) => {
                    console.error('Peer error', err);
                    // Attempt to reconnect or show an error
                });

                signalRef.child(opponentSignalKey).on('value', snap => {
                    if (snap.exists() && appState.peer && !appState.peer.destroyed) {
                        try {
                            const signalData = JSON.parse(snap.val());
                            if (!appState.peer.connected) {
                                appState.peer.signal(signalData);
                            }
                        } catch(e) {
                            console.error('Error parsing signal:', e);
                        }
                    }
                });
            },
            stop: () => {
                if (appState.localStream) {
                    appState.localStream.getTracks().forEach(track => track.stop());
                }
                if (appState.peer) {
                    appState.peer.destroy();
                }
                dom.localVideo.srcObject = null;
                dom.remoteVideo.srcObject = null;
                appState.localStream = null;
                appState.peer = null;
            }
        };
        
        const game = {
            init: () => {
                dom.controlButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        if (btn.disabled) return;
                        
                        sounds.play('click');
                        appState.playerChoice = e.currentTarget.dataset.choice;
                        
                        dom.controlButtons.forEach(b => {
                            b.classList.remove('selected');
                            b.disabled = true;
                        });
                        e.currentTarget.classList.add('selected');
                        
                        game.submitChoice();
                    });
                });
                ui.resetControlButtons(true);
            },
            
            sendInvitation: (opponentId, opponentName, bet) => {
                if (bet > appState.currentUserProfile.wallet) {
                    alert("You don't have enough coins for this bet!");
                    return;
                }

                const gameId = db.ref('games').push().key;
                const invitationKey = db.ref(`invitations/${opponentId}`).push().key;

                appState.pendingInvitation = { gameId, opponentId, invitationKey };

                const gameData = {
                    bet,
                    status: 'pending',
                    players: {
                        p1: { uid: appState.currentUser.uid, displayName: appState.currentUserProfile.displayName, wallet: appState.currentUserProfile.wallet, choice: null },
                        p2: { uid: opponentId, displayName: opponentName, wallet: 0, choice: null } // Wallet will be fetched on accept
                    },
                };

                const gameRef = db.ref(`games/${gameId}`);
                const invitationRef = db.ref(`invitations/${opponentId}/${invitationKey}`);

                gameRef.set(gameData).then(() => {
                    return invitationRef.set({ 
                        gameId, 
                        bet, 
                        fromUid: appState.currentUser.uid,
                        fromName: appState.currentUserProfile.displayName 
                    });
                }).then(() => {
                    ui.showWaitingModal(opponentName);
                    
                    gameRef.onDisconnect().remove();
                    invitationRef.onDisconnect().remove();

                    appState.activeInvitationListener = gameRef.on('value', snap => {
                        if (!snap.exists()) {
                            game.cleanUpInvitationListeners();
                            ui.hideModal();
                            alert("The invitation was declined or cancelled.");
                            return;
                        }
                        const gameVal = snap.val();
                        if (gameVal.status === 'active') {
                            game.cleanUpInvitationListeners();
                            game.join(gameId, true);
                        } else if (gameVal.status === 'declined') {
                            game.cleanUpInvitationListeners();
                            ui.hideModal();
                            alert(`${opponentName} declined the invitation.`);
                            snap.ref.remove();
                        }
                    });
                });
            },

            cancelInvitation: () => {
                if (!appState.pendingInvitation) return;
                const { gameId, opponentId, invitationKey } = appState.pendingInvitation;
                
                const gameRef = db.ref(`games/${gameId}`);
                const invitationRef = db.ref(`invitations/${opponentId}/${invitationKey}`);
                
                game.cleanUpInvitationListeners();
                
                gameRef.remove();
                invitationRef.remove();
                
                appState.pendingInvitation = null;
                ui.hideModal();
            },

            cleanUpInvitationListeners: () => {
                if (!appState.pendingInvitation) return;
                const { gameId, opponentId, invitationKey } = appState.pendingInvitation;
                const gameRef = db.ref(`games/${gameId}`);
                const invitationRef = db.ref(`invitations/${opponentId}/${invitationKey}`);
                
                if (appState.activeInvitationListener) {
                    gameRef.off('value', appState.activeInvitationListener);
                    appState.activeInvitationListener = null;
                }
                
                gameRef.onDisconnect().cancel();
                invitationRef.onDisconnect().cancel();
                
                appState.pendingInvitation = null;
            },

            declineInvitation: (gameId, invitationRef) => {
                // Update game status to declined so the sender is notified.
                db.ref(`games/${gameId}/status`).set('declined');
                if(invitationRef) invitationRef.remove();
            },

            acceptInvitation: async (gameId, invitationRef) => {
                const gameRef = db.ref(`games/${gameId}`);
                try {
                    const gameSnap = await gameRef.once('value');
                    if (!gameSnap.exists()) {
                        alert("This game invitation no longer exists.");
                        if (invitationRef) invitationRef.remove();
                        return;
                    }
                    
                    const gameData = gameSnap.val();
                    if (gameData.status !== 'pending') {
                        alert("This game is no longer available.");
                        if (invitationRef) invitationRef.remove();
                        return;
                    }
                    
                    if (appState.currentUserProfile.wallet < gameData.bet) {
                        alert("You don't have enough coins for this challenge!");
                        game.declineInvitation(gameId, invitationRef);
                        return;
                    }
                    
                    // Fetch opponent's wallet to display correctly from the start
                    const opponentProfileSnap = await db.ref(`users/${gameData.players.p1.uid}`).once('value');
                    const opponentWallet = opponentProfileSnap.val().wallet;

                    const updates = {};
                    updates[`games/${gameId}/status`] = 'active';
                    updates[`games/${gameId}/players/p1/wallet`] = opponentWallet;
                    updates[`games/${gameId}/players/p2/wallet`] = appState.currentUserProfile.wallet;
                    
                    await db.ref().update(updates);
                    
                    if (invitationRef) await invitationRef.remove();
                    
                    game.join(gameId, false);
                    
                } catch (error) {
                    console.error("Error accepting invitation:", error);
                    alert("An unexpected error occurred while joining the game.");
                    if (invitationRef) invitationRef.remove();
                }
            },
            
            join: (gameId, isCreator) => {
                appState.currentGameId = gameId;
                appState.isGameCreator = isCreator;
                dbManager.updateUserStatus('ingame');
                ui.showScreen(dom.gameScreen);
                ui.hideModal();
                webrtc.start();

                const gameRef = db.ref(`games/${gameId}`);
                appState.activeGameListener = gameRef.on('value', (snap) => game.stateMachine(snap.val()));
            },
            
            stateMachine: (gameData) => {
                if (!gameData) {
                    if (appState.currentGameId) {
                        alert("The game has ended or the opponent disconnected.");
                        game.leave();
                    }
                    return;
                }
                ui.updateGameInfo(gameData);
                
                switch (gameData.status) {
                    case 'active':
                        ui.showGameStatus("Connecting...", '', 0);
                        break;
                    case 'countdown':
                        game.handleCountdown(gameData);
                        break;
                    case 'choose':
                        const myPlayerKey = appState.isGameCreator ? 'p1' : 'p2';
                        if (!gameData.players[myPlayerKey].choice) {
                            ui.hideGameStatus();
                            ui.resetControlButtons(false);
                        } else {
                            ui.showGameStatus("Waiting for opponent...", '', 0);
                        }
                        break;
                    case 'reveal':
                        ui.resetControlButtons(true);
                        game.revealResult(gameData);
                        break;
                    case 'finished':
                        // Only show post-game options once, and not if a modal is already open
                        if (!document.getElementById('post-game-modal')) {
                             setTimeout(() => {
                                 // Check if still in game before showing modal
                                 if(appState.currentGameId) game.showPostGameOptions(gameData);
                             }, 4000);
                        }
                        break;
                }
            },
            
            startCountdown: () => {
                if (!appState.currentGameId || !appState.isGameCreator) return;
                
                const gameRef = db.ref(`games/${appState.currentGameId}`);
                gameRef.transaction(currentData => {
                    if (currentData && currentData.status === 'active') {
                        currentData.status = 'countdown';
                        currentData.countdown = 3;
                        return currentData;
                    }
                    return; // Abort transaction
                }).then(result => {
                    if (!result.committed) return;
                    let count = 3;
                    const interval = setInterval(() => {
                        if (!appState.currentGameId) {
                            clearInterval(interval);
                            return;
                        }
                        count--;
                        if (count >= 0) {
                            db.ref(`games/${appState.currentGameId}/countdown`).set(count);
                        } else {
                            clearInterval(interval);
                            // Creator moves the game to the 'choose' state
                            db.ref(`games/${appState.currentGameId}/status`).set('choose');
                        }
                    }, 1000);
                });
            },
            
            handleCountdown: (gameData) => {
                const count = gameData.countdown;
                if (count > 0) {
                    ui.showGameStatus(count);
                    sounds.play('countdown');
                } else if (count === 0) {
                    ui.showGameStatus("CHOOSE!");
                    sounds.play('alarm');
                }
            },
            
            submitChoice: () => {
                if(!appState.currentGameId || !appState.playerChoice) return;
                const playerKey = appState.isGameCreator ? 'p1' : 'p2';
                db.ref(`games/${appState.currentGameId}/players/${playerKey}/choice`).set(appState.playerChoice).then(() => {
                    ui.showGameStatus("Choice locked! Waiting for opponent...", '', 0);
                    
                    // Only creator checks if both have chosen
                    if (appState.isGameCreator) {
                        db.ref(`games/${appState.currentGameId}/players`).once('value', (snap) => {
                            const players = snap.val();
                            if (players && players.p1 && players.p2 && players.p1.choice && players.p2.choice) {
                                setTimeout(() => {
                                    db.ref(`games/${appState.currentGameId}/status`).set('reveal');
                                }, 500);
                            }
                        });
                    }
                });
            },
            
            revealResult: (gameData) => {
                if (gameData.status !== 'reveal') return; // Prevent multiple executions

                const { p1, p2 } = gameData.players;
                if(!p1.choice || !p2.choice) return;
                
                ui.showGameResult(gameData);

                const winnerChoice = game.getWinner(p1.choice, p2.choice);
                const myChoice = appState.isGameCreator ? p1.choice : p2.choice;

                if (winnerChoice === null) {
                    sounds.play('draw');
                } else if (myChoice === winnerChoice) {
                    sounds.play('win');
                } else {
                    sounds.play('lose');
                }
                
                // Only creator finalizes the game and updates wallets
                if (appState.isGameCreator) {
                    setTimeout(() => {
                        db.ref(`games/${appState.currentGameId}`).transaction(currentData => {
                            if (currentData && currentData.status === 'reveal') {
                                 currentData.status = 'finished';
                                 return currentData;
                            }
                            return; // Abort
                        }).then(result => {
                            if (result.committed) {
                                game.updateWallets(result.snapshot.val(), winnerChoice);
                            }
                        });
                    }, 2000);
                }
            },
            
            getWinner: (c1, c2) => {
                if (c1 === c2) return null;
                if ((c1 === 'rock' && c2 === 'scissors') || 
                    (c1 === 'scissors' && c2 === 'paper') || 
                    (c1 === 'paper' && c2 === 'rock')) {
                    return c1;
                }
                return c2;
            },
            
            updateWallets: (gameData, winnerChoice) => {
                if (winnerChoice === null) return Promise.resolve();
                
                const { bet, players } = gameData;
                const p1Won = players.p1.choice === winnerChoice;
                const winnerId = p1Won ? players.p1.uid : players.p2.uid;
                const loserId = p1Won ? players.p2.uid : players.p1.uid;
                
                const winnerRef = db.ref(`users/${winnerId}/wallet`);
                const loserRef = db.ref(`users/${loserId}/wallet`);

                // Use transactions for safe concurrent updates
                return Promise.all([
                    winnerRef.transaction(wallet => (wallet || 0) + bet),
                    loserRef.transaction(wallet => Math.max(0, (wallet || 0) - bet))
                ]).then(() => {
                    console.log(`Wallets updated: Winner +${bet}, Loser -${bet}`);
                }).catch(error => {
                    console.error("Wallet update failed: ", error);
                });
            },
            
            showPostGameOptions: (gameData) => {
                const myUid = appState.currentUser.uid;
                const { p1, p2 } = gameData.players;
                const myChoice = p1.uid === myUid ? p1.choice : p2.choice;
                const winnerChoice = game.getWinner(p1.choice, p2.choice);
                let resultText = "Game Over";
                if(winnerChoice === null) resultText = "It was a draw!";
                else if(winnerChoice === myChoice) resultText = `You won ${gameData.bet} coins!`;
                else resultText = `You lost ${gameData.bet} coins.`;

                const modalHTML = `
                    <div class="modal" id="post-game-modal">
                        <div class="modal-content">
                            <h3>${resultText}</h3>
                            <p>Play again or return to the lobby.</p>
                            <button id="exit-game-btn">Exit to Lobby</button>
                        </div>
                    </div>`;
                dom.modalContainer.innerHTML = modalHTML;
                document.getElementById('exit-game-btn').onclick = () => {
                     if (appState.isGameCreator) {
                        // Creator is responsible for cleaning up the game object
                        db.ref(`games/${appState.currentGameId}`).remove();
                     } else {
                        // The other player just leaves. The game object will be removed by the creator.
                        game.leave();
                     }
                }
            },
            
            leave: () => {
                ui.hideModal();
                webrtc.stop();
                
                if (appState.currentGameId && appState.activeGameListener) {
                    db.ref(`games/${appState.currentGameId}`).off('value', appState.activeGameListener);
                }
                
                if(appState.pendingInvitation) game.cleanUpInvitationListeners(); 

                dbManager.updateUserStatus('online');
                appState.currentGameId = null;
                appState.isGameCreator = false;
                appState.activeGameListener = null;
                appState.playerChoice = null;
                ui.showScreen(dom.lobbyScreen);
                ui.hideGameStatus();
                ui.resetControlButtons(true);
            }
        };

        function init() {
            console.log("Initializing Metal RPS Arena...");
            authManager.init();
            game.init();
        }

        init();
    </script>
</body>
</html>
